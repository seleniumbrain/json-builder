from below selected files, is there a way to improve the interface vs implementation class.
Scan through and refine the required methods to be inheritted from interface JsonBuilder.java
Provide metter naming and exception handling
Improve the coding to be precise and short without compromising its expected outcome and quality
sort methods in logical order

### Improvements to `JsonBuilder` Interface and `JsonObjectBuilder` Implementation

**Problem 1: Refine Methods in Interface**

Refine the methods in the `JsonBuilder` interface to ensure only necessary methods are inherited.

**Problem 2: Better Naming and Exception Handling**

Improve method names for clarity and enhance exception handling.

**Problem 3: Code Precision and Quality**

Make the code more precise and maintain quality without compromising the expected outcome.

**Problem 4: Logical Order of Methods**

Sort methods in a logical order for better readability and maintainability.

### Refined `JsonBuilder` Interface

```java
package org.json.builder.core;

import com.fasterxml.jackson.databind.JsonNode;

import java.io.File;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;

public interface JsonBuilder {

    JsonBuilder fromJsonFile(String jsonFileName);

    JsonBuilder fromJsonFile(File jsonFile);

    JsonBuilder fromJsonString(String json);

    JsonBuilder withEmptyNode();

    JsonBuilder append(String jsonNodePath, Object value, String dataTypeOfValue);

    JsonBuilder append(String jsonNodePath, Object value);

    JsonBuilder updateArrayNodeIf(Predicate<JsonNode> condition, String arrayNodePath, String key, String newValue);

    JsonBuilder updateObjectNodeIf(Predicate<JsonNode> condition, String objectNodePath, String key, String newValue);

    JsonBuilder remove(String jsonNodePath);

    JsonBuilder build();

    JsonBuilder writeTo(String filePath);

    String toPrettyString();

    JsonNode buildAsJsonNode();

    JsonNode getNodeAt(String jsonNodePath);

    void clean();

    boolean isBuilderEmpty();

    <T> T transformToPojo(Class<T> classType);

    <T> T transformNodeToPojo(String jsonNodePath, Class<T> classType);

    List<String> extractJsonPaths();

    Map<String, String> extractJsonPathValueMap();
}
```

### Improved `JsonObjectBuilder` Implementation

```java
package org.json.builder.core;

import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.SneakyThrows;
import org.apache.commons.lang3.StringUtils;
import org.json.builder.exception.JsonBuilderException;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Predicate;

public class JsonObjectBuilder implements JsonBuilder {

    private final Map<String, Object> jsonPathValueMapToAppend = new LinkedHashMap<>();
    private final Map<String, Object> jsonPathValueMapToRemove = new LinkedHashMap<>();
    private ObjectNode rootObjectNode = MAPPER.createObjectNode();

    @Override
    @SneakyThrows
    public synchronized JsonObjectBuilder fromJsonFile(String jsonFileName) {
        validateFileName(jsonFileName);
        this.rootObjectNode = (ObjectNode) MAPPER.readTree(new File(jsonFileName));
        return this;
    }

    @Override
    @SneakyThrows
    public synchronized JsonObjectBuilder fromJsonFile(File jsonFile) {
        validateFile(jsonFile);
        this.rootObjectNode = (ObjectNode) MAPPER.readTree(jsonFile);
        return this;
    }

    @Override
    @SneakyThrows
    public synchronized JsonObjectBuilder fromJsonString(String json) {
        validateJsonString(json);
        this.rootObjectNode = (ObjectNode) MAPPER.readTree(json);
        return this;
    }

    @Override
    @SneakyThrows
    public synchronized JsonObjectBuilder withEmptyNode() {
        this.rootObjectNode = MAPPER.createObjectNode();
        return this;
    }

    @Override
    public synchronized JsonObjectBuilder append(String jsonNodePath, Object value, String dataTypeOfValue) {
        if (JsonBuilder.isNotSkippable(value)) {
            jsonPathValueMapToAppend.put(convertPath(jsonNodePath), JsonBuilder.convertValueOfRequiredDataType(value, dataTypeOfValue));
        }
        return this;
    }

    @Override
    public synchronized JsonObjectBuilder append(String jsonNodePath, Object value) {
        return append(jsonNodePath, value, NodeValueType.STRING.getType());
    }

    @Override
    public synchronized JsonObjectBuilder updateArrayNodeIf(Predicate<JsonNode> condition, String arrayNodePath, String key, String newValue) {
        updateNodeIf(condition, arrayNodePath, key, newValue, true);
        return this;
    }

    @Override
    public synchronized JsonObjectBuilder updateObjectNodeIf(Predicate<JsonNode> condition, String objectNodePath, String key, String newValue) {
        updateNodeIf(condition, objectNodePath, key, newValue, false);
        return this;
    }

    @Override
    public synchronized JsonObjectBuilder remove(String jsonNodePath) {
        jsonPathValueMapToRemove.put(convertPath(jsonNodePath), "");
        return this;
    }

    @Override
    public synchronized JsonObjectBuilder build() {
        jsonPathValueMapToAppend.forEach((key, value) -> setJsonPointerValue(rootObjectNode, JsonPointer.compile(key), (JsonNode) value));
        jsonPathValueMapToAppend.clear();
        jsonPathValueMapToRemove.forEach((key, value) -> removeJsonPointerValue(rootObjectNode, JsonPointer.compile(key)));
        jsonPathValueMapToRemove.clear();
        return this;
    }

    @SneakyThrows
    @Override
    public synchronized JsonObjectBuilder writeTo(String filePath) {
        Files.writeString(Paths.get(filePath), toPrettyString());
        return this;
    }

    @Override
    public synchronized String toPrettyString() {
        build();
        return rootObjectNode.toPrettyString();
    }

    @Override
    public synchronized JsonNode buildAsJsonNode() {
        build();
        validateRootNode();
        return rootObjectNode;
    }

    @Override
    public synchronized JsonNode getNodeAt(String jsonNodePath) {
        return rootObjectNode.at(convertPath(jsonNodePath));
    }

    @Override
    public synchronized void clean() {
        rootObjectNode.removeAll();
        jsonPathValueMapToAppend.clear();
        jsonPathValueMapToRemove.clear();
    }

    @Override
    public synchronized boolean isBuilderEmpty() {
        return rootObjectNode.isNull() || rootObjectNode.isEmpty() || rootObjectNode.isMissingNode();
    }

    @Override
    @SneakyThrows
    public synchronized <T> T transformToPojo(Class<T> classType) {
        return MAPPER.treeToValue(rootObjectNode, classType);
    }

    @Override
    @SneakyThrows
    public synchronized <T> T transformNodeToPojo(String jsonNodePath, Class<T> classType) {
        return MAPPER.treeToValue(rootObjectNode.at(convertPath(jsonNodePath)), classType);
    }

    @Override
    public synchronized List<String> extractJsonPaths() {
        return JsonBuilder.printJsonPath(rootObjectNode, StringUtils.EMPTY, new ArrayList<>());
    }

    @Override
    public synchronized Map<String, String> extractJsonPathValueMap() {
        return JsonBuilder.printJsonPathKeyValuePair(rootObjectNode, StringUtils.EMPTY, new HashMap<>());
    }

    private void setJsonPointerValue(ObjectNode node, JsonPointer pointer, JsonNode value) {
        JsonPointer parentPointer = pointer.head();
        JsonNode parentNode = node.at(parentPointer);
        String fieldName = pointer.last().toString().substring(1);

        if (parentNode.isMissingNode() || parentNode.isNull()) {
            parentNode = StringUtils.isNumeric(fieldName) ? MAPPER.createArrayNode() : MAPPER.createObjectNode();
            setJsonPointerValue(node, parentPointer, parentNode);
        }

        if (parentNode.isArray()) {
            ArrayNode arrayNode = (ArrayNode) parentNode;
            int index = Integer.parseInt(fieldName);
            for (int i = arrayNode.size(); i <= index; i++) {
                arrayNode.addObject();
            }
            arrayNode.set(index, value);
        } else if (parentNode.isObject()) {
            ((ObjectNode) parentNode).set(fieldName, value);
        } else {
            throw new IllegalArgumentException("Invalid parent node type for field: " + fieldName);
        }
    }

    private void removeJsonPointerValue(ObjectNode node, JsonPointer pointer) {
        JsonPointer parentPointer = pointer.head();
        JsonNode parentNode = node.at(parentPointer);
        String fieldName = pointer.last().toString().substring(1);

        if (parentNode.isMissingNode() || parentNode.isNull()) {
            return;
        }

        if (parentNode.isArray()) {
            ((ArrayNode) parentNode).remove(Integer.parseInt(fieldName));
        } else if (parentNode.isObject()) {
            ((ObjectNode) parentNode).remove(fieldName);
        } else {
            throw new IllegalArgumentException("Invalid parent node type for field: " + fieldName);
        }
    }

    private void updateNodeIf(Predicate<JsonNode> condition, String nodePath, String key, String newValue, boolean isArray) {
        JsonNode node = getNodeAt(nodePath);
        if (isArray && node.isArray()) {
            for (int i = 0; i < node.size(); i++) {
                if (condition.test(node.get(i))) {
                    append(nodePath + "[" + i + "]." + key, newValue);
                }
            }
        } else if (!isArray && node.isObject()) {
            if (condition.test(node)) {
                append(nodePath + "." + key, newValue);
            }
        } else {
            throw new JsonBuilderException("Invalid node type for path: " + nodePath);
        }
    }

    private void validateFileName(String fileName) {
        if (fileName.isBlank()) {
            throw new JsonBuilderException("File name is blank.");
        }
    }

    private void validateFile(File file) {
        if (!file.exists() || !file.isFile()) {
            throw new JsonBuilderException("Invalid file.");
        }
    }

    private void validateJsonString(String json) {
        if (Objects.isNull(json) || json.isBlank()) {
            throw new JsonBuilderException("Invalid JSON string.");
        }
    }

    private void validateRootNode() {
        if (Objects.isNull(rootObjectNode)) {
            throw new JsonBuilderException("Root node is null.");
        }
    }

    private String convertPath(String jsonNodePath) {
        return JsonBuilder.convertJsonNodePathWithSlashSeparator(jsonNodePath);
    }
}
```